# 函数 

## 1. 函数基础

### 1.1 为何使用函数

1. 最大化代码重用和最小化代码冗余。

2. 流程的分解。
### 1.2 函数主要概念
编写函数就如同内置函数一样：通过表达式进行调用，传入值，并返回结果。

1. def是可执行的语句--函数并不存在，直至运行了def后才存在。
2. 运行到def语句时，生成一个新的函数对象并将其赋值给这个函数名。此时就像所有的赋值一样，函数成为某一个函数的引用。
3. lambda创建对象并将其做为结果返回。
4. return将函数执行结果对象发送给调用者。
5. yield向调用者发回一个结果对象，但是记住它离开的地方。（挂起状态以便稍后能够恢复状态）
6. global声明模块级变量并被赋值。（区分本地变量）
7. nonlocal声明将要赋值的一个封闭的函数变量。
8. 多态：可以支持多种类型，只要其支持扩展对象接口。
9. 本地变量：只在def内的函数中可以，并且仅在函数运行时存在。所有的本地变量都会在函数调用时出现，并在函数退出时消失。

## 2. 作用域

1. 在代码中变量名被赋值的位置决定了这个变量名能被访问的范围。

    1.1 如果一个变量在def内赋值，它被定位在这个函数之内。

    1.2 如果在def之外赋值，它就是整个文件全局的。

    1.3 如果一个变量在一个嵌套的def中赋值，对于嵌套的函数来说，它是非本地的。

2. 函数为程序增加的额外命名空间层：

    1.1 一个在def内定义的变量名能被def内代码使用，不能在外部引用这样的变量名。

    1.2 def之中变量名与def之外的变量名不冲突。

3. 作用域法则：函数定义本地作用域，模块定义全局作用域

    3.1 在函数内部，除非声明为全局变量或非本地变量，否则均为本地变量。

    3.2 每次调用函数都将创建一个新的本地作用域。

    3.3 在一个文件的顶层的变量名仅对这个文件内部代码而言是全局的。即每个模块都是一个全局作用域。

4. 内置作用域

    仅仅是一个名为__builtin__的内置模块。

5. global语句

    只是一个命名空间的声明。

    5.1 全局变量是位于模块文件内部顶层的变量名。
    
    5.2 全局变量在函数内部不经过声明也可被引用。

    5.3 全局变量在函数内被赋值修改的话，必须经过声明。

6. 作用域和嵌套函数
    
    工厂函数：记住嵌套作用域变量值的函数，尽管那个作用域或许已经不存在。

7. 作用域与带有循环变量的默认参数比较：

    嵌套在一个循环之中，并且嵌套的函数引用了一个上层作用域的变量，该变量被循环所改变，所有在这个循环中产生的函数将会有相同的值--最后一次循环中完成时被引用变量的值。

    因为嵌套作用域中的变量在嵌套的函数被调用时才进行查找。

    为了让这类代码能够工作，必须使用默认参数把当前的值传递给嵌套作用域的变量。因为默认参数时在嵌套函数创建时评估的。


8. nonlocal：允许一个嵌套函数来修改在一个语法嵌套函数的作用域定义的一个或多个名称。

    为什么使用：在很多程序中，状态信息很重要。


## 3. 参数

### 3.1 传递参数

1. 参数的传递是通过自动将对象赋值给本地变量名实现。
2. 

### 3.2 避免可变参数被修改
默认和可变对象：可变类型的默认参数在函数调用之间保存了他们的状态，在一定程度上，他们工作起来就像全局变量。但是他们的变量名对于函数来说是本地变量。

### 3.3 传入参数类型
1. 位置参数：通过位置匹配
2. 默认参数：
3. 关键字参数：通过变量名匹配
4. 传递所有对象，并作为独立的基于位置的参数。元组
5. 传递所有对象，并作为独立的关键字参数。字典

    4&5 解包参数 *args，**args：解包参数集合。

6. 指定keyword-only：必须按照关键字传递并且不会由一个位置参数来填充。

    在参数列表中使用一个*，来表示一个函数不会接受一个变量长度的参数列表。

## 4. 高级话题（闭包、装饰器）

### 4.1 递归

1. 每次迭代都有一个班本地作用域的副本。

### 4.2 函数内省

由于函数是对象，所以可以使用常规的对象工具来处理函数。

1. func.__name__ 
2. dir(func)：检查属性
3. 可向函数附加任意的用户定义的属性。可以直接把状态信息附加到函数对象。

### 4.3 函数注解__annotations__

### 4.4 匿名函数 lambda
1. lambda是一个表达式，而不是一个语句。其返回一个值（一个新的函数），可以选择性的赋值给一个变量名。
2. 其主题是一个单个的表达式，而不是一个代码块。仅能封装有限的逻辑，连if这样的语句都不能使用。
3. 默认参数也能在其中起作用，与def遵循相同的作用域查找法则。
4. map\filter\reduce

### 4.5 生成器
编写为常规的def语句，但是使用yield语句一次返回一个结果，在每个结果之间挂起和继续他们的状态。

节省内存空间，并允许计算时间分散到各个结果请求。

生成器函数和生成器表达式都是迭代器，并只支持一次活跃迭代。

### 4.6
列表解析

生成器表达式

解析集合

字段解析

### 4.7 
在交互模式下输入或从一个模块文件中导入时，python读入并编译这级代码。在编译时，python看到了对x的赋值语句，并决定x在函数中的任一地方都是本地变量名。


